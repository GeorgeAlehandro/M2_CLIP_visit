---
title: "simulate_cycle"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulate_cycle}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(VeloSim)
```
## Step 1: Define the simulation parameters
```{r params_setting}
# number of total cells
ncells_total <- 2000
# number of total genes
ngenes <- 1000
# total number of evfs: homo-evf + diff-evf
nevf <- 20
# number of diff-evf
n_de_evf <- 12
# which kinetic parameters is changed according to the sampling position, n_de_evf is used in s
vary <- "all"
# the standard deviation of the gaussian distribution, denote the noise size
Sigma <- 0.1
# the mean of the homo-evf, gaussian distribution again
evf_center <- 1
# with which probability the gene effect value is preserved
gene_effect_prob <- 0.3
# the mean of the gaussian distribution of gene effect
geffect_mean <- 0
# the standard deviation of the gaussian distribution of gene effect
gene_effects_sd <- 1
# the real data to obtain the kinetic parameter distribution from
param_realdata <- "zeisel.imputed"
bimod <- 0
scale_s <- 1
randseed <- 2
# read in tree
phyla <- ape::read.tree(system.file("extdata", "Newick_ABCD.txt", package = "VeloSim"))
par(mfrow=c(1,2))
plot(phyla)
```

## Step 2: Simulate data according to the parameters
`SimulateVeloCycle` is the main function of VeloSim. This function is designed specifically for cell-cycle trajectory structure, user can generate the unspliced, spliced counts, true developmental time and true RNA velocity and kinetic parameters using this function.
```{r simulation}
# simulate data

result_true <- SimulateVeloTree(ncells_total=ncells_total,ngenes=ngenes, evf_center=1,nevf=nevf,
                           phyla=phyla, randseed=randseed, n_de_evf=n_de_evf,vary=vary,Sigma=Sigma,geffect_mean=geffect_mean,
                           gene_effects_sd=gene_effects_sd,gene_effect_prob=gene_effect_prob,
                           bimod=bimod,param_realdata=param_realdata,scale_s=scale_s,
                           prop_hge=0.015, mean_hge=5, n_unstable=0, plot = FALSE)
# add technical noise
result <- technicalNoise(result_true, capture.rate = 0.2)
```

## Step 3: Store the result
Store the unspliced count, spliced count, cell developmental time and RNA velocity
```{r save_file}
# unspliced count
write.table(result$counts_u, file = "./counts_u.csv")
# spliced count
write.table(result$counts_s, file = "./counts_s.csv")
# cell developmental time
write.table(result$cell_time, file = "./pseudo_time.csv")
# RNA velocity
write.table(result$velocity, file = "./velocity.csv")
```

## Step 4: Plot the result
```{r plotting}
# Plot with cell developmental time(pseudo-time), default PCA
plotPseudotime(filename = "pseudotime.pdf", result)
# Plot with RNA velocity
plotVelo(filename = "velocity.pdf", result, arrow.length = 0.3, width = 7, height = 7)
# Plot with cell developmental time(pseudo-time), using UMAP
plotPseudotime(filename = "pseudotime_umap.pdf", result, dr = "umap")
```

```{r}
plotBackbone <- function(result, dr = "pca", width = 15, height = 15, units = "in", dpi = 1000){
  library(ggplot2)

  counts_u <- result$counts_u
  counts_s <- result$counts_s
  kinetic_params <- result$kinet_params
  state_mat <- result$state_mat
  backbone <- result$backbone
  velocity <- result$velocity

  if(dr == "pca") {
    pca_res <- prcomp(log1p(t(counts_s)), scale. = F)
    x_dr <- as.data.frame(pca_res$x)
    x_dr$backbone <- backbone
  } else if(dr == "umap") {
    config = umap.defaults
    config$n_neighbors = 30
    umap_res <- umap(d=t(log1p(counts_s)), config = config)
    x_dr <- as.data.frame(umap_res$layout)
    colnames(x_dr) <- c("PC1", "PC2")
    x_dr$backbone <- backbone
  } else {stop("The dr can only be umap or pca")}

  theme<-theme(panel.background = element_blank(),
               panel.border=element_rect(fill=NA),
               panel.grid.major = element_blank(),
               panel.grid.minor = element_blank(),
               strip.background=element_blank(),
               axis.text.x=element_text(colour="black"),
               axis.text.y=element_text(colour="black"),
               axis.ticks=element_line(colour="black"),
               plot.margin=unit(c(1,1,1,1),"line"))

  plt <- ggplot(data = x_dr) + geom_point(mapping = aes(x = PC1, y = PC2, color = backbone)) + theme
return(plt)
}
```

```{r}
# Plot with cell developmental time(pseudo-time), using UMAP
plot<-plotBackbone(result, dr = "umap")
```

```{r}
count_s_pca <- prcomp(t(result$counts_s), scale. = T, center = T)
```

```{r}
# Extract rotation matrix and scale values from the output of the first PCA
rotation_matrix <- count_s_pca$rotation
scale_values <- count_s_pca$scale

# Perform PCA on second dataset using the same rotation matrix and scale values
#velocity_pca <- prcomp(t(result$velocity), center = TRUE, scale. = TRUE, rotation = rotation_matrix, scale = scale_values)
scaled_velocity <- scale(t(result$velocity), center = TRUE, scale = scale_values)

# Multiply the scaled second dataset by the rotation matrix from the first PCA
velocity_pca <- scaled_velocity %*% rotation_matrix

```

```{r}
count_s_100_pca <- count_s_pca[["x"]][,1:100]
velocity_100_pca <- velocity_pca[,1:100]
```

```{r}
export_simulation <- list()
  export_simulation$counts_u <- result$counts_u
  export_simulation$counts_s_PCA <- as.matrix(count_s_100_pca)
  export_simulation$counts_s <- result$counts_s
  export_simulation$backbone <- result$backbone
  export_simulation$velocity <- result$velocity
  export_simulation$velocity_100_pca <- velocity_100_pca
```

```{r}
saveRDS(export_simulation, "/data/VeloSIM/datasets/2000_100_0.2.rds")
```

```{r}
write.csv(as.data.frame(t(result$counts_u)),"/data/data_frames_to_anndata/2000_100_0.2_unspliced.csv")
write.csv(as.data.frame(t(result$counts_s)),"/data/data_frames_to_anndata/2000_100_0.2_spliced.csv")
write.csv(as.data.frame(result$backbone),"/data/data_frames_to_anndata/backbone.csv")
```



```{r}
library("anndata")
reticulate::install_miniconda()
```
```{r}
my_adata <- AnnData(var = result$counts_u[0,],
                    X = result$counts_u[,0])
```
# Extract firt 100 PCAS
```{r}


```

```{r}
write.csv(count_s_100_pca,"/data/data_frames_to_anndata/2000_100_0.2_unspliced.csv")
```

